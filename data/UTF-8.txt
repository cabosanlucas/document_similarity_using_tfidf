UTF-8 is a variable width character encoding capable of encoding all 1,112,064[1] valid code points in Unicode using one to four 8-bit bytes.[2] The encoding is defined by the Unicode standard, and was originally designed by Ken Thompson and Rob Pike.[3][4] The name is derived from Unicode (or Universal Coded Character Set) Transformation Format¬†‚Äì  8-bit.[5]
It was designed for backward compatibility with ASCII. Code points with lower numerical values, which tend to occur more frequently, are encoded using fewer bytes. The first 128 characters of Unicode, which correspond one-to-one with ASCII, are encoded using a single octet with the same binary value as ASCII, so that valid ASCII text is valid UTF-8-encoded Unicode as well. Since ASCII bytes do not occur when encoding non-ASCII code points into UTF-8, UTF-8 is safe to use within most programming and document languages that interpret certain ASCII characters in a special way, such as "/" in filenames, "\" in escape sequences, and "%" in printf.




Shows the usage of the main encodings on the web from 2001 to 2012 as recorded by Google,[6] with UTF-8 overtaking all others in 2008 and nearing 50% of the web in 2012.
Note that the ASCII only figure includes web pages with any declared header if they are restricted to ASCII characters.


UTF-8 has been the dominant character encoding for the World Wide Web since 2009, and as of 2018 accounts for 90.5% of all Web pages (much of which are just pages with ASCII, as it's a subset of UTF-8; the next-most popular multibyte encodings, Shift JIS and GB 2312, have 0.8% and 0.6% respectively).[7][8][6] The Internet Mail Consortium (IMC) recommended that all e-mail programs be able to display and create mail using UTF-8,[9] and the W3C recommends UTF-8 as the default encoding in XML and HTML.[10]



Contents


1 Description

1.1 Examples
1.2 Codepage layout
1.3 Overlong encodings
1.4 Invalid byte sequences
1.5 Invalid code points


2 Official name and variants
3 Derivatives

3.1 CESU-8
3.2 Modified UTF-8
3.3 WTF-8


4 Byte order mark
5 History
6 Comparison with single-byte encodings
7 Comparison with other multi-byte encodings
8 Comparison with UTF-16
9 See also
10 Notes
11 References
12 External links



Description[edit]
Since the restriction of the Unicode code-space to 21-bit values in 2003, UTF-8 is defined to encode code points in one to four bytes, depending on the number of significant bits in the numerical value of the code point. The following table shows the structure of the encoding. The x characters are replaced by the bits of the code point. If the number of significant bits is no more than seven, the first line applies; if no more than 11¬†bits, the second line applies, and so on.


Number
of bytes
Bits for
code point
First
code point
Last
code point
Byte 1
Byte 2
Byte 3
Byte 4


1
7
U+0000
U+007F
0xxxxxxx





2
11
U+0080
U+07FF
110xxxxx
10xxxxxx




3
16
U+0800
U+FFFF
1110xxxx
10xxxxxx
10xxxxxx



4
21
U+10000
U+10FFFF
11110xxx
10xxxxxx
10xxxxxx
10xxxxxx


The first 128 characters (US-ASCII) need one byte. The next 1,920 characters need two bytes to encode, which covers the remainder of almost all Latin-script alphabets, and also Greek, Cyrillic, Coptic, Armenian, Hebrew, Arabic, Syriac, Thaana and N'Ko alphabets, as well as Combining Diacritical Marks. Three bytes are needed for characters in the rest of the Basic Multilingual Plane, which contains virtually all characters in common use[11] including most Chinese, Japanese and Korean characters. Four bytes are needed for characters in the other planes of Unicode, which include less common CJK characters, various historic scripts, mathematical symbols, and emoji (pictographic symbols).
Some of the important features of this encoding are as follows:

Backward compatibility: Backwards compatibility with ASCII and the enormous amount of software designed to process ASCII-encoded text was the main driving force behind the design of UTF-8. In UTF-8, single bytes with values in the range of 0 to 127 map directly to Unicode code points in the ASCII range. Single bytes in this range represent characters, as they do in ASCII. Moreover, 7-bit bytes (bytes where the most significant bit is 0) never appear in a multi-byte sequence, and no valid multi-byte sequence decodes to an ASCII code-point. A sequence of 7-bit bytes is both valid ASCII and valid UTF-8, and under either interpretation represents the same sequence of characters. Therefore, the 7-bit bytes in a UTF-8 stream represent all and only the ASCII characters in the stream. Thus, many text processors, parsers, protocols, file formats, text display programs etc., which use ASCII characters for formatting and control purposes will continue to work as intended by treating the UTF-8 byte stream as a sequence of single-byte characters, without decoding the multi-byte sequences. ASCII characters on which the processing turns, such as punctuation, whitespace, and control characters will never be encoded as multi-byte sequences. It is therefore safe for such processors to simply ignore or pass-through the multi-byte sequences, without decoding them. For example, ASCII whitespace may be used to tokenize a UTF-8 stream into words; ASCII line-feeds may be used to split a UTF-8 stream into lines; and ASCII NUL characters can be used to split UTF-8-encoded data into null-terminated strings. Similarly, many format strings used by library functions like "printf" will correctly handle UTF-8-encoded input arguments.
Fallback and auto-detection: UTF-8 provided backwards compatibility for 7-bit ASCII, but much software and data uses 8-bit extended ASCII encodings designed prior to the adoption of Unicode to represent the character sets of European languages. Part of the popularity of UTF-8 is due to the fact that it provides a form of backward compatibility for these as well. A UTF-8 processor which erroneously receives an extended ASCII file as input can "fall back" or replace 8-bit bytes using the appropriate code-point in the Unicode Latin-1 Supplement block, when the 8-bit byte appears outside a valid multi-byte sequence. Though it does happen, the 8-bit characters in extended ASCII encodings do not usually have the correct form for UTF-8 multi-byte sequences. This is because the 8-bit bytes which introduce multi-byte sequences in UTF-8 are primarily accented letters (mostly vowels) in the common extended ASCII encodings, and the UTF-8 continuation bytes are punctuation and symbol characters. To appear as a valid UTF-8 multi-byte sequence, a series of 2 to 4 extended ASCII 8-bit characters would have to be an unusual combination of symbols and accented letters. In short, extended ASCII character sequences which look like valid UTF-8 multi-byte sequences are unlikely. Fallback errors will be false negatives, and these will be rare. Moreover, in many applications, such as text display, the consequence of incorrect fallback is usually slight. Only legibility is affected, and not significantly. These two things make fallback feasible, if somewhat imperfect. Indeed, as discussed further below, the HTML5 standard requires that erroneous bytes in supposed UTF-8 data be replaced upon display on the assumption that they are Windows-1252 characters. The presence of invalid 8-bit characters outside valid multi-byte sequences can also be used to "auto-detect" that an encoding is actually an extended ASCII encoding rather than UTF-8, and decode it accordingly. A UTF-8 stream may simply contain errors, resulting in the auto-detection scheme producing false positives; but auto-detection is successful in the majority of cases, especially with longer texts, and is widely used.
Prefix code: The first byte indicates the number of bytes in the sequence. Reading from a stream can instantaneously decode each individual fully received sequence, without first having to wait for either the first byte of a next sequence or an end-of-stream indication. The length of multi-byte sequences is easily determined by humans as it is simply the number of high-order 1s in the leading byte. An incorrect character will not be decoded if a stream ends mid-sequence.
Self-synchronization: The leading bytes and the continuation bytes do not share values (continuation bytes start with 10 while single bytes start with 0 and longer lead bytes start with 11). This means a search will not accidentally find the sequence for one character starting in the middle of another character. It also means the start of a character can be found from a random position by backing up at most 3 bytes to find the leading byte. An incorrect character will not be decoded if a stream starts mid-sequence, and a shorter sequence will never appear inside a longer one.
Sorting order: The chosen values of the leading bytes and the fact that the continuation bytes have the high-order bits first means that a list of UTF-8 strings can be sorted in code point order by sorting the corresponding byte sequences.

Examples[edit]
Consider the encoding of the Euro sign, ‚Ç¨.

The Unicode code point for "‚Ç¨" is U+20AC.
According to the scheme table above, this will take three bytes to encode, since it is between U+0800 and U+FFFF.
Hexadecimal 20AC is binary 0010 0000 1010 1100. The two leading zeros are added because, as the scheme table shows, a three-byte encoding needs exactly sixteen bits from the code point.
Because the encoding will be three bytes long, its leading byte starts with three 1s, then a 0 (1110...)
The four most significant bits of the code point are stored in the remaining low order four bits of this byte (1110 0010), leaving 12 bits of the code point yet to be encoded (...0000 1010 1100).
All continuation bytes contain exactly six bits from the code point. So the next six bits of the code point are stored in the low order six bits of the next byte, and 10 is stored in the high order two bits to mark it as a continuation byte (so 1000 0010).
Finally the last six bits of the code point are stored in the low order six bits of the final byte, and again 10 is stored in the high order two bits (1010 1100).

The three bytes 1110 0010 1000 0010 1010 1100 can be more concisely written in hexadecimal, as E2 82 AC.
Since UTF-8 uses groups of six bits, it is sometimes useful to use octal notation which uses 3-bit groups. With a calculator which can convert between hexadecimal and octal it can be easier to manually create or interpret UTF-8 compared with using binary.

Octal 0200‚Äì3777 (hex 80-7FF) shall be coded with two bytes. xxyy will be 3xx 2yy.
Octal 4000‚Äì177777 (hex 800-FFFF) shall be coded with three bytes. xxyyzz will be (340+xx) 2yy 2zz.
Octal 200000-4177777 (hex 10000-10FFFF) shall be coded with four bytes. wxxyyzz will be 36w 2xx 2yy 2zz.

The following table summarises this conversion, as well as others with different lengths in UTF-8. The colors indicate how bits from the code point are distributed among the UTF-8 bytes. Additional bits added by the UTF-8 encoding process are shown in black.


Character
Octal code point
Binary code point
Binary UTF-8
Octal UTF-8
Hexadecimal UTF-8


$
U+0024
044
010 0100
00100100
044
24


¬¢
U+00A2
0242
000 1010 0010
11000010 10100010
302 242
C2 A2


‚Ç¨
U+20AC
020254
0010 0000 1010 1100
11100010 10000010 10101100
342 202 254
E2 82 AC


êçà
U+10348
0201510
0 0001 0000 0011 0100 1000
11110000 10010000 10001101 10001000
360 220 215 210
F0 90 8D 88


Codepage layout[edit]
The following table summarizes usage of UTF-8 code units (individual bytes or octets) in a code page format. The upper half (0_ to 7_) is for bytes used only in single-byte codes, so it looks like a normal code page; the lower half is for continuation bytes (8_ to B_) and (possible) leading bytes (C_ to F_), and is explained further in the legend below.

UTF-8


_0
_1
_2
_3
_4
_5
_6
_7
_8
_9
_A
_B
_C
_D
_E
_F


0_
NUL
0000
0
SOH
0001
1
STX
0002
2
ETX
0003
3
EOT
0004
4
ENQ
0005
5
ACK
0006
6
BEL
0007
7
BS
0008
8
HT
0009
9
LF
000A
10
VT
000B
11
FF
000C
12
CR
000D
13
SO
000E
14
SI
000F
15


1_
DLE
0010
16
DC1
0011
17
DC2
0012
18
DC3
0013
19
DC4
0014
20
NAK
0015
21
SYN
0016
22
ETB
0017
23
CAN
0018
24
EM
0019
25
SUB
001A
26
ESC
001B
27
FS
001C
28
GS
001D
29
RS
001E
30
US
001F
31


2_
SP
0020
32
!
0021
33
"
0022
34
#
0023
35
$
0024
36
%
0025
37
&
0026
38
'
0027
39
(
0028
40
)
0029
41
*
002A
42
+
002B
43
,
002C
44
-
002D
45
.
002E
46
/
002F
47


3_
0
0030
48
1
0031
49
2
0032
50
3
0033
51
4
0034
52
5
0035
53
6
0036
54
7
0037
55
8
0038
56
9
0039
57
:
003A
58
;
003B
59
<
003C
60
=
003D
61
>
003E
62
?
003F
63


4_
@
0040
64
A
0041
65
B
0042
66
C
0043
67
D
0044
68
E
0045
69
F
0046
70
G
0047
71
H
0048
72
I
0049
73
J
004A
74
K
004B
75
L
004C
76
M
004D
77
N
004E
78
O
004F
79


5_
P
0050
80
Q
0051
81
R
0052
82
S
0053
83
T
0054
84
U
0055
85
V
0056
86
W
0057
87
X
0058
88
Y
0059
89
Z
005A
90
[
005B
91
\
005C
92
]
005D
93
^
005E
94
_
005F
95


6_
`
0060
96
a
0061
97
b
0062
98
c
0063
99
d
0064
100
e
0065
101
f
0066
102
g
0067
103
h
0068
104
i
0069
105
j
006A
106
k
006B
107
l
006C
108
m
006D
109
n
006E
110
o
006F
111


7_
p
0070
112
q
0071
113
r
0072
114
s
0073
115
t
0074
116
u
0075
117
v
0076
118
w
0077
119
x
0078
120
y
0079
121
z
007A
122
{
007B
123
|
007C
124
}
007D
125
~
007E
126
DEL
007F
127


8_
‚Ä¢
+00
128
‚Ä¢
+01
129
‚Ä¢
+02
130
‚Ä¢
+03
131
‚Ä¢
+04
132
‚Ä¢
+05
133
‚Ä¢
+06
134
‚Ä¢
+07
135
‚Ä¢
+08
136
‚Ä¢
+09
137
‚Ä¢
+0A
138
‚Ä¢
+0B
139
‚Ä¢
+0C
140
‚Ä¢
+0D
141
‚Ä¢
+0E
142
‚Ä¢
+0F
143


9_
‚Ä¢
+10
144
‚Ä¢
+11
145
‚Ä¢
+12
146
‚Ä¢
+13
147
‚Ä¢
+14
148
‚Ä¢
+15
149
‚Ä¢
+16
150
‚Ä¢
+17
151
‚Ä¢
+18
152
‚Ä¢
+19
153
‚Ä¢
+1A
154
‚Ä¢
+1B
155
‚Ä¢
+1C
156
‚Ä¢
+1D
157
‚Ä¢
+1E
158
‚Ä¢
+1F
159


A_
‚Ä¢
+20
160
‚Ä¢
+21
161
‚Ä¢
+22
162
‚Ä¢
+23
163
‚Ä¢
+24
164
‚Ä¢
+25
165
‚Ä¢
+26
166
‚Ä¢
+27
167
‚Ä¢
+28
168
‚Ä¢
+29
169
‚Ä¢
+2A
170
‚Ä¢
+2B
171
‚Ä¢
+2C
172
‚Ä¢
+2D
173
‚Ä¢
+2E
174
‚Ä¢
+2F
175


B_
‚Ä¢
+30
176
‚Ä¢
+31
177
‚Ä¢
+32
178
‚Ä¢
+33
179
‚Ä¢
+34
180
‚Ä¢
+35
181
‚Ä¢
+36
182
‚Ä¢
+37
183
‚Ä¢
+38
184
‚Ä¢
+39
185
‚Ä¢
+3A
186
‚Ä¢
+3B
187
‚Ä¢
+3C
188
‚Ä¢
+3D
189
‚Ä¢
+3E
190
‚Ä¢
+3F
191


2-byte
C_


192


193
Latin
0080
194
Latin
00C0
195
Latin
0100
196
Latin
0140
197
Latin
0180
198
Latin
01C0
199
Latin
0200
200
IPA
0240
201
IPA
0280
202
IPA
02C0
203
accents
0300
204
accents
0340
205
Greek
0380
206
Greek
03C0
207


2-byte
D_
Cyril
0400
208
Cyril
0440
209
Cyril
0480
210
Cyril
04C0
211
Cyril
0500
212
Armeni
0540
213
Hebrew
0580
214
Hebrew
05C0
215
Arabic
0600
216
Arabic
0640
217
Arabic
0680
218
Arabic
06C0
219
Syriac
0700
220
Arabic
0740
221
Thaana
0780
222
N'Ko
07C0
223


3-byte
E_
Indic
0800
224
Misc.
1000
225
Symbol
2000
226
Kana, CJK
3000
227
CJK
4000
228
CJK
5000
229
CJK
6000
230
CJK
7000
231
CJK
8000
232
CJK
9000
233
Asian
A000
234
Hangul
B000
235
Hangul
C000
236
Hangul
D000
237
PUA
E000
238
Forms
F000
239


4‚Äëbyte
F_
SMP, SIP
10000
240

40000
241

80000
242
SSP, SPUA
C0000
243
SPUA-B
100000
244


245


246


247


248


249


250


251


252


253


254


255


Orange cells with a large dot are continuation bytes. The hexadecimal number shown after a "+" plus sign is the value of the six bits they add.
White cells are the leading bytes for a sequence of multiple bytes, the length shown at the left edge of the row. The text shows the Unicode blocks encoded by sequences starting with this byte, and the hexadecimal code point shown in the cell is the lowest character value encoded using that leading byte.
Red cells must never appear in a valid UTF-8 sequence. The first two red cells (C0 and C1) could be used only for a two-byte encoding of a 7-bit ASCII character which should be encoded in one byte; as described below such "overlong" sequences are disallowed. The red cells in the F row (F5 to FD) indicate leading bytes of 4-byte or longer sequences that cannot be valid because they would encode code points larger than the U+10FFFF limit of Unicode (a limit derived from the maximum code point encodable in UTF-16), and FE and FF were never defined for any purpose in UTF-8.
Pink cells are the leading bytes for a sequence of multiple bytes, of which some, but not all, possible continuation sequences are valid. E0 and F0 could start overlong encodings, in this case the lowest non-overlong-encoded code point is shown. F4 can start code points greater than U+10FFFF which are invalid. ED can start the encoding of a code point in the range U+D800‚ÄìU+DFFF; these are invalid since they are reserved for UTF-16 surrogate halves.
Overlong encodings[edit]
In principle, it would be possible to inflate the number of bytes in an encoding by padding the code point with leading 0s. To encode the Euro sign ‚Ç¨ from the above example in four bytes instead of three, it could be padded with leading 0s until it was 21¬†bits long¬†‚Äì  000 000010 000010 101100, and encoded as 11110000 10000010 10000010 10101100 (or F0 82 82 AC in hexadecimal). This is called an overlong encoding.
The standard specifies that the correct encoding of a code point use only the minimum number of bytes required to hold the significant bits of the code point. Longer encodings are called overlong and are not valid UTF-8 representations of the code point. This rule maintains a one-to-one correspondence between code points and their valid encodings, so that there is a unique valid encoding for each code point. This ensures that string comparisons and searches are well-defined.
Modified UTF-8 uses the two-byte overlong encoding of U+0000 (the NUL character), 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00). This allows the byte 00 to be used as a string terminator.
Invalid byte sequences[edit]
Not all sequences of bytes are valid UTF-8. A UTF-8 decoder should be prepared for:

the red invalid bytes in the above table
an unexpected continuation byte
a leading byte not followed by enough continuation bytes (can happen in simple string truncation, when a string is too long to fit when copying it)
an overlong encoding as described above
a sequence that decodes to an invalid code point as described below

Many earlier decoders would happily try to decode these. Carefully crafted invalid UTF-8 could make them either skip or create ASCII characters such as NUL, slash, or quotes. Invalid UTF-8 has been used to bypass security validations in high-profile products including Microsoft's IIS web server[12] and Apache's Tomcat servlet container.[13]
RFC 3629 states "Implementations of the decoding algorithm MUST protect against decoding invalid sequences."[14] The Unicode Standard requires decoders to "...treat any ill-formed code unit sequence as an error condition. This guarantees that it will neither interpret nor emit an ill-formed code unit sequence."
Many UTF-8 decoders throw exceptions on encountering errors.[15] This can turn what would otherwise be harmless errors (producing a message such as "no such file") into a denial of service bug. Early versions of Python 3.0 would exit immediately if the command line or environment variables contained invalid UTF-8,[16] making it impossible to handle such errors.
More recent converters translate the first byte of an invalid sequence to a replacement character and continue parsing with the next byte. These error bytes will always have the high bit set. This avoids denial-of-service bugs, and it is very common in text rendering such as browser display, since mangled text is probably more useful than nothing for helping the user figure out what the string was supposed to contain. Popular replacements include:

The replacement character "ÔøΩ" (U+FFFD) (or EF BF BD in UTF-8)
The invalid Unicode code points U+DC80‚ÄìU+DCFF where the low eight bits are the byte's value.[17] Sometimes it is called UTF-8B[18]
The Unicode code points U+0080‚ÄìU+00FF with the same value as the byte, thus interpreting the bytes according to ISO-8859-1[citation needed]
The Unicode code point for the character represented by the byte in CP1252,[citation needed] which is similar to using ISO-8859-1, except that some characters in the range 0x80‚Äì0x9F are mapped into different Unicode code points. For example, 0x80 becomes the Euro sign, U+20AC.

These replacement algorithms are "lossy", as more than one sequence is translated to the same code point. This means that it would not be possible to reliably convert back to the original encoding, therefore losing information. Reserving 128 code points (such as U+DC80‚ÄìU+DCFF) to indicate errors, and defining the UTF-8 encoding of these points as invalid so they convert to 3 errors, would seem to make conversion lossless. But this runs into practical difficulties: the converted text cannot be modified such that errors are arranged so they convert back into valid UTF-8, which means if the conversion is UTF-16, it cannot also be used to store arbitrary invalid UTF-16, which is usually needed on the same systems that need invalid UTF-8. U+DC80‚ÄìU+DCFF are reserved for UTF-16 surrogates, so that when they are used for UTF-8 in this way, and the string is converted to UTF-16 this can lead to bugs or the string being rejected.
The large number of invalid byte sequences provides the advantage of making it easy to have a program accept both UTF-8 and legacy encodings such as ISO-8859-1. Software can check for UTF-8 correctness, and if that fails assume the input to be in the legacy encoding. It is technically true that this may detect an ISO-8859-1 string as UTF-8, but this is very unlikely if it contains any 8-bit bytes as they all have to be in unusual patterns of two or more in a row, such as "√Ç¬£".
Invalid code points[edit]
Since RFC 3629 (November 2003), the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) and code points not encodable by UTF-16 (those after U+10FFFF) are not legal Unicode values, and their UTF-8 encoding must be treated as an invalid byte sequence.
Not decoding surrogate halves makes it impossible to store invalid UTF-16, such as Windows filenames, as UTF-8. Therefore, detecting these as errors is often not implemented and there are attempts to define this behavior formally (see WTF-8 and CESU below).
Official name and variants[edit]
The official Internet Assigned Numbers Authority (IANA) code for the encoding is "UTF-8".[19] All letters are upper-case, and the name is hyphenated. This spelling is used in all the Unicode Consortium documents relating to the encoding.
Alternatively, the name "utf-8" may be used by all standards conforming to the IANA list (which include CSS, HTML, XML, and HTTP headers),[20] as the declaration is case insensitive.[19]
Other descriptions that omit the hyphen or replace it with a space, such as "utf8" or "UTF 8", are not accepted as correct by the governing standards.[14] Despite this, most agents such as browsers can understand them, and so standards intended to describe existing practice (such as HTML5) may effectively require their recognition.
Unofficially, UTF-8-BOM and UTF-8-NOBOM are sometimes used to refer to text files which respectively contain and lack a byte order mark (BOM).[citation needed] In Japan especially, UTF-8 encoding without BOM is sometimes called "UTF-8N".[21][22]
In PCL, UTF-8 is called Symbol-ID "18N" (PCL supports 183 character encodings, called Symbol Sets, which potentially could be reduced to one, 18N, that is UTF-8).[23]
Derivatives[edit]
The following implementations show slight differences from the UTF-8 specification. They are incompatible with the UTF-8 specification and may be rejected by conforming UTF-8 applications.
CESU-8[edit]
Main article: CESU-8
Many programs added UTF-8 conversions for UCS-2 data and did not alter this UTF-8 conversion when UCS-2 was replaced with the surrogate-pair using UTF-16. In such programs each half of a UTF-16 surrogate pair is encoded as its own three-byte UTF-8 encoding, resulting in six-byte sequences rather than four bytes for characters outside the Basic Multilingual Plane. Oracle and MySQL databases use this, as well as Java and Tcl as described below, and probably many Windows programs where the programmers were unaware of the complexities of UTF-16. Although this non-optimal encoding is generally not deliberate, a supposed benefit is that it preserves UTF-16 binary sorting order when CESU-8 is binary sorted.
Modified UTF-8[edit]
In Modified UTF-8 (MUTF-8),[24] the null character (U+0000) uses the two-byte overlong encoding 11000000 10000000 (hexadecimal C0 80), instead of 00000000 (hexadecimal 00). Modified UTF-8 strings never contain any actual null bytes but can contain all Unicode code points including U+0000,[25] which allows such strings (with a null byte appended) to be processed by traditional null-terminated string functions.
All known Modified UTF-8 implementations also treat the surrogate pairs as in CESU-8.
In normal usage, the Java programming language supports standard UTF-8 when reading and writing strings through InputStreamReader and OutputStreamWriter (if it is the platform's default character set or as requested by the program). However it uses Modified UTF-8 for object serialization[26] among other applications of DataInput and DataOutput, for the Java Native Interface,[27] and for embedding constant strings in class files.[28] The dex format defined by Dalvik also uses the same modified UTF-8 to represent string values.[29] Tcl also uses the same modified UTF-8[30] as Java for internal representation of Unicode data, but uses strict CESU-8 for external data.
WTF-8[edit]
WTF-8 (Wobbly Transformation Format ‚Äì 8-bit) is an extension of UTF-8 where the encodings of the surrogate halves (U+D800 through U+DFFF) are allowed.[31] This is necessary to store possibly-invalid UTF-16, such as Windows filenames. Many systems that deal with UTF-8 work this way without considering it a different encoding, as it is simpler.
WTF-8 has been used to refer to erroneously doubly-encoded UTF-8.[32][33][34]
Byte order mark[edit]
Main article: Byte order mark
Many Windows programs (including Windows Notepad) add the bytes 0xEF, 0xBB, 0xBF at the start of any document saved as UTF-8. This is the UTF-8 encoding of the Unicode byte order mark (BOM), and is commonly referred to as a UTF-8 BOM, even though it is not relevant to byte order. A BOM can also appear if another encoding with a BOM is translated to UTF-8 without stripping it. Software that is not aware of multibyte encodings will display the BOM as three garbage characters at the start of the document, e.g. "√Ø¬ª¬ø" in software interpreting the document as ISO 8859-1 or Windows-1252 or "‚à©‚ïó‚îê" if interpreted as code page 437, a default for certain older Windows console applications.
The Unicode Standard neither requires nor recommends the use of the BOM for UTF-8, but warns that it may be encountered at the start of a file as a transcoding artifact.[35] The presence of the UTF-8 BOM may cause problems with existing software that can handle UTF-8, for example:

Programming language parsers not explicitly designed for UTF-8 can often handle UTF-8 in string constants and comments, but will choke on encountering an UTF-8 BOM at the start of the file.
Programs that identify file types by leading characters may fail to identify the file if a UTF-8 BOM is present even if the user of the file could skip the BOM. An example is the Unix shebang syntax. Another example is Internet Explorer which will render pages in standards mode only when it starts with a document type declaration[citation needed].
Programs that insert information at the start of a file will break use of the BOM to identify UTF-8 (one example is offline browsers that add the originating URL to the start of the file[citation needed]).

History[edit]
By early 1992, the search was on for a good byte stream encoding of multi-byte character sets. The draft ISO 10646 standard contained a non-required annex called UTF-1 that provided a byte stream encoding of its 32-bit code points. This encoding was not satisfactory on performance grounds, among other problems, and the biggest problem was probably that it did not have a clear separation between ASCII and non-ASCII: new UTF-1 tools would be backward compatible with ASCII-encoded text, but UTF-1-encoded text could confuse existing code expecting ASCII (or extended ASCII), because it could contain continuation bytes in the range 0x21‚Äì0x7E that meant something else in ASCII, e.g., 0x2F for '/', the Unix path directory separator, and this example is reflected in the name and introductory text of its replacement. The table below was derived from a textual description in the annex.

UTF-1

Number
of bytes
First
code point
Last
code point
Byte 1
Byte 2
Byte 3
Byte 4
Byte 5


1
U+0000
U+009F
00‚Äì9F






2
U+00A0
U+00FF
A0
A0‚ÄìFF





2
U+0100
U+4015
A1‚ÄìF5
21‚Äì7E, A0‚ÄìFF





3
U+4016
U+38E2D
F6‚ÄìFB
21‚Äì7E, A0‚ÄìFF
21‚Äì7E, A0‚ÄìFF




5
U+38E2E
U+7FFFFFFF
FC‚ÄìFF
21‚Äì7E, A0‚ÄìFF
21‚Äì7E, A0‚ÄìFF
21‚Äì7E, A0‚ÄìFF
21‚Äì7E, A0‚ÄìFF


In July 1992, the X/Open committee XoJIG was looking for a better encoding. Dave Prosser of Unix System Laboratories submitted a proposal for one that had faster implementation characteristics and introduced the improvement that 7-bit ASCII characters would only represent themselves; all multibyte sequences would include only bytes where the high bit was set. The name File System Safe UCS Transformation Format (FSS-UTF) and most of the text of this proposal were later preserved in the final specification.[36][37][38][39]

FSS-UTF proposal (1992)

Number
of bytes
Bits for
code point
First
code point
Last
code point
Byte 1
Byte 2
Byte 3
Byte 4
Byte 5


1
7
U+0000
U+007F
0xxxxxxx






2
13
U+0080
U+207F
10xxxxxx
1xxxxxxx





3
19
U+2080
U+8207F
110xxxxx
1xxxxxxx
1xxxxxxx




4
25
U+82080
U+208207F
1110xxxx
1xxxxxxx
1xxxxxxx
1xxxxxxx



5
31
U+2082080
U+7FFFFFFF
11110xxx
1xxxxxxx
1xxxxxxx
1xxxxxxx
1xxxxxxx


In August 1992, this proposal was circulated by an IBM X/Open representative to interested parties. A modification by Ken Thompson of the Plan 9 operating system group at Bell Labs made it somewhat less bit-efficient than the previous proposal but crucially allowed it to be self-synchronizing, letting a reader start anywhere and immediately detect byte sequence boundaries. It also abandoned the use of biases and instead added the rule that only the shortest possible encoding is allowed; the additional loss in compactness is relatively insignificant, but readers now have to look out for invalid encodings to avoid reliability and especially security issues. Thompson's design was outlined on September 2, 1992, on a placemat in a New Jersey diner with Rob Pike. In the following days, Pike and Thompson implemented it and updated Plan 9 to use it throughout, and then communicated their success back to X/Open, which accepted it as the specification for FSS-UTF.[38]

FSS-UTF (1992) / UTF-8 (1993)[3]

Number
of bytes
Bits for
code point
First
code point
Last
code point
Byte 1
Byte 2
Byte 3
Byte 4
Byte 5
Byte 6


1
7
U+0000
U+007F
0xxxxxxx







2
11
U+0080
U+07FF
110xxxxx
10xxxxxx






3
16
U+0800
U+FFFF
1110xxxx
10xxxxxx
10xxxxxx





4
21
U+10000
U+1FFFFF
11110xxx
10xxxxxx
10xxxxxx
10xxxxxx




5
26
U+200000
U+3FFFFFF
111110xx
10xxxxxx
10xxxxxx
10xxxxxx
10xxxxxx



6
31
U+4000000
U+7FFFFFFF
1111110x
10xxxxxx
10xxxxxx
10xxxxxx
10xxxxxx
10xxxxxx


UTF-8 was first officially presented at the USENIX conference in San Diego, from January 25 to 29, 1993.
In November 2003, UTF-8 was restricted by RFC 3629 to match the constraints of the UTF-16 character encoding: explicitly prohibiting code points corresponding to the high and low surrogate characters removed more than 3% of the three-byte sequences, and ending at U+10FFFF removed more than 48% of the four-byte sequences and all five- and six-byte sequences.
Google reported that in 2008, UTF-8 (labelled "Unicode") became the most common encoding for HTML files.[40]
Comparison with single-byte encodings[edit]

UTF-8 can encode any Unicode character, avoiding the need to figure out and set a "code page" or otherwise indicate what character set is in use, and allowing output in multiple scripts at the same time. For many scripts there have been more than one single-byte encoding in usage, so even knowing the script was insufficient information to display it correctly.
The bytes 0xFE and 0xFF do not appear, so a valid UTF-8 stream never matches the UTF-16 byte order mark and thus cannot be confused with it. The absence of 0xFF (0377) also eliminates the need to escape this byte in Telnet (and FTP control connection).
UTF-8 encoded text is larger than specialized single-byte encodings except for plain ASCII characters. In the case of scripts which used 8-bit character sets with non-Latin characters encoded in the upper half (such as most Cyrillic and Greek alphabet code pages), characters in UTF-8 will be double the size. For some scripts, such as Thai and Devanagari (which is used by various South Asian languages), characters will triple in size. There are even examples where a single byte turns into a composite character in Unicode and is thus six times larger in UTF-8. This has caused objections in India and other countries.
It is possible in UTF-8 (or any other multi-byte encoding) to split or truncate a string in the middle of a character. This can result in an invalid string which some software refuses to accept. A good parser should ignore a truncated character at the end, which is easy in UTF-8 but tricky in some other multi-byte encodings.
If the code points are all the same size, measurements of a fixed number of them is easy. Due to ASCII-era documentation where "character" is used as a synonym for "byte" this is often considered important. However, by measuring string positions using bytes instead of "characters" most algorithms can be easily and efficiently adapted for UTF-8. Searching for a string within a long string can for example be done byte by byte; the self-synchronization property prevents false positives.
Some software, such as text editors, will refuse to correctly display or interpret UTF-8 unless the text starts with a byte order mark, and will insert such a mark. This has the effect of making it impossible to use UTF-8 with any older software that can handle ASCII-like encodings but cannot handle the byte order mark. This, however, is no problem of UTF-8 itself but one of bad software implementations.

Comparison with other multi-byte encodings[edit]

UTF-8 can encode any Unicode character. Files in different scripts can be displayed correctly without having to choose the correct code page or font. For instance Chinese and Arabic can be supported (in the same text) without special codes inserted or manual settings to switch the encoding.
UTF-8 is self-synchronizing: character boundaries are easily identified by scanning for well-defined bit patterns in either direction. If bytes are lost due to error or corruption, one can always locate the next valid character and resume processing. If there is a need to shorten a string to fit a specified field, the previous valid character can easily be found. Many multi-byte encodings are much harder to resynchronize.
Any byte oriented string searching algorithm can be used with UTF-8 data, since the sequence of bytes for a character cannot occur anywhere else. Some older variable-length encodings (such as Shift JIS) did not have this property and thus made string-matching algorithms rather complicated. In Shift JIS the end byte of a character and the first byte of the next character could look like another legal character, something that can't happen in UTF-8.
Efficient to encode using simple bit operations. UTF-8 does not require slower mathematical operations such as multiplication or division (unlike the obsolete UTF-1 encoding).
UTF-8 will take more space than a multi-byte encoding designed for a specific script. East Asian legacy encodings generally used two bytes per character yet take three bytes per character in UTF-8.

Comparison with UTF-16[edit]

Byte encodings and UTF-8 are represented by byte arrays in programs, and often nothing needs to be done to a function when converting from a byte encoding to UTF-8. UTF-16 is represented by 16-bit word arrays, and converting to UTF-16 while maintaining compatibility with existing ASCII-based programs (such as was done with Windows) requires every API and data structure that takes a string to be duplicated, one version accepting byte strings and another version accepting UTF-16.
Text encoded in UTF-8 will be smaller than the same text encoded in UTF-16 if there are more code points below U+0080 than in the range U+0800..U+FFFF. This is true for all modern European languages.

Most of the rich text formats (including HTML) contain a large proportion of ASCII characters for the sake of formatting, thus the size usually will be reduced significantly compared with UTF-16, even when the language mostly uses 3-byte long characters in UTF-8.[nb 1]


Most communication (e.g. HTML and IP) and storage (e.g. for Unix) was designed for a stream of bytes. A UTF-16 string must use a pair of bytes for each code unit:

The order of those two bytes becomes an issue and must be specified in the UTF-16 protocol, such as with a byte order mark.
If an odd number of bytes is missing from UTF-16, the whole rest of the string will be meaningless text. Any bytes missing from UTF-8 will still allow the text to be recovered accurately starting with the next character after the missing bytes.


Characters U+0800 through U+FFFF use three bytes in UTF-8, but only two in UTF-16. As a result, text in (for example) Chinese, Japanese or Devanagari will take more space in UTF-8 if there are more of these characters than there are ASCII characters. This is possible when data mainly consist of pure prose, but is lessened by the degree to which the context uses ASCII whitespace, digits, and punctuation.[nb 2]

See also[edit]


Alt code
Character encodings in HTML
Comparison of e-mail clients ¬ß¬†Features
Comparison of Unicode encodings
GB 18030
Iconv ‚Äì a standardized API used to convert between different character encodings
ISO/IEC 8859
Specials (Unicode block)
Unicode and e-mail
Unicode and HTML
Universal Character Set
UTF-8 in URIs
UTF-EBCDIC
UTF-9 and UTF-18
UTF-16/UCS-2


Notes[edit]



^ The 2010-10-27 version of UTF-8 generated 169¬†KB when converted with Notepad to UTF-16, and only 101¬†KB when converted back to UTF-8. The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi) required 119¬†KB in UTF-16 and 76¬†KB in UTF-8.
^ The 2010-11-22 version of ‡§Ø‡•Ç‡§®‡§ø‡§ï‡•ã‡§° (Unicode in Hindi), when the pure text was pasted to Notepad, generated 19¬†KB when saved as UTF-16 and 22¬†KB when saved as UTF-8.



References[edit]


^ 17√ó216 = 1,114,112 code points minus 2,048 technically-invalid surrogate code points
^ A group of eight bits is known as an octet in the Unicode Standard.
^ a b Email Subject: UTF-8 history, From: "Rob 'Commander' Pike", Date: Wed, 30 Apr 2003..., ...UTF-8 was designed, in front of my eyes, on a placemat in a New Jersey diner one night in September or so 1992...So that night Ken wrote packing and unpacking code and I started tearing into the C and graphics libraries. The next day all the code was done...
^ Pike, Rob; Thompson, Ken (1993). "Hello World or ŒöŒ±ŒªŒ∑ŒºŒ≠œÅŒ± Œ∫œåœÉŒºŒµ or „Åì„Çì„Å´„Å°„ÅØ ‰∏ñÁïå". Proceedings of the Winter 1993 USENIX Conference (PDF).¬†
^ "Chapter 2. General Structure". The Unicode Standard (6.0 ed.). Mountain View, California, US: The Unicode Consortium. ISBN¬†978-1-936213-01-6.¬†
^ a b Davis, Mark (2010-01-28). "Unicode nearing 50% of the web". Official Google Blog. Google. Retrieved 2010-12-05.¬†
^ "Historical trends in the usage of character encodings". Retrieved 2018-01-03.¬†
^ "UTF-8 Usage Statistics". BuiltWith. Retrieved 2011-03-28.¬†
^ "Using International Characters in Internet Mail". Internet Mail Consortium. 1998-08-01. Retrieved 2007-11-08.¬†
^ "Specifying the document's character encoding", HTML5, World Wide Web Consortium, 2014-06-17, retrieved 2014-07-30¬†
^ Allen, Julie D.; Anderson, Deborah; Becker, Joe; Cook, Richard, eds. (2012). "The Unicode Standard, Version 6.1". Mountain View, California: Unicode Consortium. The Basic Multilingual Plane (BMP, or Plane 0) contains the common-use characters for all the modern scripts of the world as well as many historical and rare characters. By far the majority of all Unicode characters for almost all textual data can be found in the BMP.¬†
^ Marin, Marvin (2000-10-17). "Web Server Folder Traversal MS00-078".¬†
^ "National Vulnerability Database ‚Äì Summary for CVE-2008-2938".¬†
^ a b Yergeau, F. (2003). "RFC 3629 ‚Äì UTF-8, a transformation format of ISO 10646". Internet Engineering Task Force. Retrieved 2015-02-03.¬†
^ Java's DataInput IO Interface
^ "Non-decodable Bytes in System Character Interfaces". python.org. 2009-04-22. Retrieved 2014-08-13.¬†
^ Kuhn, Markus (2000-07-23). "Substituting malformed UTF-8 sequences in a decoder". Archived from the original on 2015-03-15. Retrieved 2014-09-25.¬†
^ Sittler, B. (2006-04-02). "Binary vs. UTF-8, and why it need not matter". Archived from the original on 2014-07-23. Retrieved 2014-09-25.¬†
^ a b "Character Sets". Internet Assigned Numbers Authority. 2013-01-23. Retrieved 2013-02-08.¬†
^ D√ºrst, Martin. "Setting the HTTP charset parameter". W3C. Retrieved 2013-02-08.¬†
^ "BOM ‚Äì suikawiki" (in Japanese). Retrieved 2013-04-26.¬†
^ Davis, Mark. "Forms of Unicode". IBM. Archived from the original on 2005-05-06. Retrieved 2013-09-18.¬†
^ PCL Symbol Sets
^ "Java SE documentation for Interface java.io.DataInput, subsection on Modified UTF-8". Oracle Corporation. 2015. Retrieved 2015-10-16.¬†
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16. Java virtual machine UTF-8 strings never have embedded nulls.¬†
^ "Java Object Serialization Specification, chapter 6: Object Serialization Stream Protocol, section 2: Stream Elements". Oracle Corporation. 2010. Retrieved 2015-10-16. [‚Ä¶] encoded in modified UTF-8.¬†
^ "Java Native Interface Specification, chapter 3: JNI Types and Data Structures, section: Modified UTF-8 Strings". Oracle Corporation. 2015. Retrieved 2015-10-16. The JNI uses modified UTF-8 strings to represent various string types.¬†
^ "The Java Virtual Machine Specification, section 4.4.7: "The CONSTANT_Utf8_info Structure"". Oracle Corporation. 2015. Retrieved 2015-10-16. [‚Ä¶] differences between this format and the 'standard' UTF-8 format.¬†
^ "ART and Dalvik". Android Open Source Project. Retrieved 2013-04-09. [T]he dex format encodes its string data in a de facto standard modified UTF-8 form, hereafter referred to as MUTF-8.¬†
^ "Tcler's Wiki: UTF-8 bit by bit (Revision 6)". 2009-04-25. Retrieved 2009-05-22. In orthodox UTF-8, a NUL byte (\x00) is represented by a NUL byte. [‚Ä¶] But [‚Ä¶] we [‚Ä¶] want NUL bytes inside [‚Ä¶] strings [‚Ä¶]¬†
^ Sapin, Simon (2016-03-11) [2014-09-25]. "The WTF-8 encoding". Archived from the original on 2016-05-24. Retrieved 2016-05-24.¬†
^ "WTF-8.com". 2006-05-18. Retrieved 2016-06-21.¬†
^ Speer, Rob (2015-05-21). "ftfy (fixes text for you) 4.0: changing less and fixing more". Retrieved 2016-06-21.¬†
^ "WTF-8, a transformation format of code page 1252". www-uxsup.csx.cam.ac.uk. Retrieved 2016-10-12.¬†
^ "The Unicode Standard ‚Äì Chapter 2" (PDF). p.¬†30.¬†
^ "Appendix F. FSS-UTF / File System Safe UCS Transformation format" (PDF). The Unicode Standard 1.1. Archived (PDF) from the original on 2016-06-07. Retrieved 2016-06-07.¬†
^ Whistler, Kenneth (2001-06-12). "FSS-UTF, UTF-2, UTF-8, and UTF-16". Archived from the original on 2016-06-07. Retrieved 2006-06-07.¬†
^ a b Pike, Rob (2003-04-30). "UTF-8 history". Retrieved 2012-09-07.¬†
^ Pike, Rob (2012-09-06). "UTF-8 turned 20 years old yesterday". Retrieved 2012-09-07.¬†
^ Davis, Mark (2008-05-05). "Moving to Unicode 5.1". Retrieved 2013-03-01.¬†


External links[edit]



Look up UTF-8 in Wiktionary, the free dictionary.


There are several current definitions of UTF-8 in various standards documents:

RFC 3629 / STD 63 (2003), which establishes UTF-8 as a standard Internet protocol element
The Unicode Standard, Version 10.0, ¬ß3.9 D92, ¬ß3.10 D95 (2017 June 20)
ISO/IEC 10646:2014 ¬ß9.1

They supersede the definitions given in the following obsolete works:

ISO/IEC 10646-1:1993 Amendment 2 / Annex R (1996)
The Unicode Standard, Version 6.0, ¬ß3.9 D92, ¬ß3.10 D95 (2010)
The Unicode Standard, Version 5.0, ¬ß3.9‚Äì¬ß3.10 (2006)
The Unicode Standard, Version 2.0, Appendix A (1996)
RFC 2044 (1996)
RFC 2279 (1998)
The Unicode Standard, Version 3.0, ¬ß2.3 (2000) plus Corrigendum #1¬†: UTF-8 Shortest Form (2000)
Unicode Standard Annex #27: Unicode 3.1 (2001)

They are all the same in their general mechanics, with the main differences being on issues such as allowed range of code point values and safe handling of invalid input.

Original UTF-8 paper (or pdf) for Plan 9 from Bell Labs
RFC 5198 defines UTF-8 NFC for Network Interchange
UTF-8 test pages by Andreas Prilop, Jost Gippert and the World Wide Web Consortium
Unix/Linux: UTF-8/Unicode FAQ, Linux Unicode HOWTO, UTF-8 and Gentoo
The Unicode/UTF-8-character table displays UTF-8 in a variety of formats (with Unicode and HTML encoding information)
Characters, Symbols and the Unicode Miracle ‚Äì Computerphile on YouTube







v
t
e


Unicode



Unicode



Unicode Consortium
ISO/IEC 10646 (Universal Character Set)
Versions





Code points



Blocks
Universal Character Set
Character charts
Character property
Planes
Private Use Areas





Characters




Special purpose



BOM
Combining Grapheme Joiner
Left-to-right mark / Right-to-left mark
Soft hyphen
Word joiner
Zero-width joiner
Zero-width non-joiner
Zero-width space





Lists



Characters
CJK Unified Ideographs
Combining character
Duplicate characters
Numerals
Scripts
Spaces
Symbols
Halfwidth and fullwidth








Processing




Algorithms



Bi-directional text
Collation

ISO 14651


Equivalence
Variation sequences
International Ideographs Core





Comparison



BOCU-1
CESU-8
Punycode
SCSU
UTF-1
UTF-7
UTF-8
UTF-9/UTF-18
UTF-16/UCS-2
UTF-32/UCS-4
UTF-EBCDIC








On pairs of
code points



Combining character
Compatibility characters
Duplicate characters
Equivalence
Homoglyph
Precomposed character

list


Z-variant
Variation sequences
Regional Indicator Symbol
Fitzpatrick modifiers





Usage



Domain names (IDN)
Email
Fonts
HTML

entity references
numeric references


Input
International Ideographs Core





Related standards



Common Locale Data Repository (CLDR)
GB 18030
ISO/IEC 8859
ISO 15924





Related topics



Anomalies
ConScript Unicode Registry
Ideographic Rapporteur Group
International Components for Unicode
People involved with Unicode
Han unification










Scripts and symbols in Unicode



Common and
inherited scripts



Combining marks
Diacritics
Punctuation
Space
Numbers





Modern scripts



Adlam
Arabic

diacritics


Armenian
Balinese
Bamum
Batak
Bengali
Bopomofo
Braille
Buhid
Burmese
Canadian Aboriginal
Chakma
Cham
Cherokee
CJK Unified Ideographs (Han)
Cyrillic
Deseret
Devanagari
Ge'ez
Georgian
Greek
Gujarati
Gurmukhƒ´
Hangul
Hanja
Hanun√≥'o
Hebrew

diacritics


Hiragana
Javanese
Kanji
Kannada
Katakana
Kayah Li
Khmer
Khudawadi
Lao
Latin
Lepcha
Limbu
Lisu (Fraser)
Lontara
Malayalam
Mandaic
Masaram Gondi
Meetei Mayek
Mende Kikakui
Miao (Pollard)
Mongolian
Mro
N'Ko
New Tai Lue
Newa
Nushu
Ol Chiki
Oriya
Osage
Osmanya
Pahawh Hmong
Pau Cin Hau
Rejang
Samaritan
≈öƒÅradƒÅ
Saurashtra
Shavian
Sinhala
Sorang Sompeng
Sundanese
Sylheti Nagari
Syriac
Tagalog (Baybayin)
Tagbanwa
Tai Le
Tai Tham
Tai Viet
Takri
Tamil
Telugu
Thaana
Thai
Tibetan
Tifinagh
Tirhuta
Vai
Warang Citi
Yi





Ancient and
historic scripts



Ahom
Anatolian hieroglyphs
Ancient North Arabian
Avestan
Bassa Vah
Bhaiksuki
BrƒÅhmƒ´
Carian
Caucasian Albanian
Coptic
Cuneiform
Cypriot
Egyptian hieroglyphs
Elbasan
Glagolitic
Gothic
Grantha
Hatran
Imperial Aramaic
Inscriptional Pahlavi
Inscriptional Parthian
Kaithi
Kharosthi
Khojki
Linear A
Linear B
Lycian
Lydian
Mahajani
Manichaean
Marchen
Meroitic
Modi
Multani
Nabataean
Ogham
Old Hungarian
Old Italic
Old Permic
Old Persian cuneiform
Old Turkic
Palmyrene
'Phags-pa
Phoenician
Psalter Pahlavi
Runic
Siddham
South Arabian
Soyombo
Tangut
Ugaritic
Zanabazar Square





Notational scripts



Duployan
SignWriting





Symbols



Cultural, political, and religious symbols
Currency
Mathematical operators and symbols
Phonetic symbols (including IPA)
Emoji















v
t
e


Character encodings



Early telecommunications



ASCII
ISO/IEC 646
ISO/IEC 6937
T.61
BCDIC
Baudot code
Morse code

Telegraph code
Wabun code


Special telegraphy codes

Non-Latin
Chinese
Cyrillic


Needle telegraph codes





ISO/IEC 8859



-1
-2
-3
-4
-5
-6
-7
-8
-9
-10
-11
-12
-13
-14
-15
-16





Bibliographic use



ANSEL
ISO 5426 / 5426-2 / 5427 / 5428 / 6438 / 6861 / 6862 / 10585 / 10586 / 10754 / 11822
MARC-8





National standards



ArmSCII
BraSCII
CNS 11643
ELOT 927
GOST 10859
GB 18030
HKSCS
ISCII
JIS X 0201
JIS X 0208
JIS X 0212
JIS X 0213
KOI-7
KPS 9566
KS X 1001
PASCII
SI 960
TIS-620
TSCII
VISCII
YUSCII





EUC



CN
JP
KR
TW





ISO/IEC 2022



CN
JP
KR
CCCII





MacOS code pages
("scripts")



Arabic
Celtic
CentEuro
ChineseSimp / EUC-CN
ChineseTrad / Big5
Croatian
Cyrillic
Devanagari
Dingbats
Esperanto
Farsi
Gaelic
Greek
Gujarati
Gurmukhi
Hebrew
Iceland
Japanese / ShiftJIS
Korean / EUC-KR
Latin-1
Roman
Romanian
S√°mi
Symbol
Thai / TIS-620
Turkish
Ukrainian





DOS code pages



100
111
112
113
151
152
161
162
163
164
165
166
210
220
301
437
449
489
620
667
668
707
708
709
710
711
714
715
720
721
737
768
770
771
772
773
774
775
776
777
778
790
850
851
852
853
854
855/872
856
857
858
859
860
861
862
863
864/17248
865
866/808
867
868
869
874/1161/1162
876
877
878
881
882
883
884
885
891
895
896
897
898
899
900
903
904
906
907
909
910
911
926
927
928
929
932
934
936
938
941
942
943
944
946
947
948
949
950/1370
951
966
991
1034
1039
1040
1041
1042
1043
1044
1046
1086
1088
1092
1093
1098
1108
1109
1114
1115
1116
1117
1118
1119
1125/848
1126
1127
1131/849
1139
1167
1168
1300
1351
1361
1362
1363
1372
1373
1374
1375
1380
1381
1385
1386
1391
1392
1393
1394
Kamenick√Ω
Mazovia
CWI-2
KOI8
MIK
Iran System





IBM AIX code pages



367
371
806
813
819
895
896
912
913
914
915
916
919
920
921/901
922/902
923
952
953
954
955
956
957
958
959
960
961
963
964
965
970
971
1004
1006
1008
1009
1010
1011
1012
1013
1014
1015
1016
1017
1018
1019
1029
1036
1089
1111
1124
1129/1163
1133
1350
1382
1383





IBM Apple MacIntosh
emulations



1275
1280
1281
1282
1283
1284
1285
1286





IBM Adobe emulations



1038
1276
1277





IBM DEC emulations



1020
1021
1023
1090
1100
1101
1102
1103
1104
1105
1106
1107
1287
1288





IBM HP emulations



1050
1051
1052
1053
1054
1055
1056
1057
1058





Windows code pages



CER-GS
874/1162 (TIS-620)
932/943 (Shift JIS)
936/1386 (GBK)
950/1370 (Big5)
949/1363 (EUC-KR)
1169
1174
Extended Latin-8
1200 (UTF-16LE)
1201 (UTF-16BE)
1250
1251
1252
1253
1254
1255
1256
1257
1258
1259
1261
1270
54936 (GB18030)





EBCDIC code pages



1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37/1140
38
39
40
251
252
254
256
257
258
259
260
264
273/1141
274
275
276
277/1142
278/1143
279
280/1144
281
282
283
284/1145
285/1146
286
287
288
289
290
293
297/1147
298
300
310
320
321
322
330
351
352
353
355
357
358
359
360
361
363
382
383
384
385
386
387
388
389
390
391
392
393
394
395
410
420/16804
421
423
424/8616/12712
425
435
500/1148
803
829
833
834
835
836
837
838/838
839
870/1110/1153
871/1149
875/4971/9067
880
881
882
883
884
885
886
887
888
889
890
892
893
905
918
924
930/1390
931
933/1364
935/1388
937/1371
939/1399
1001
1002
1003
1005
1007
1024
1025/1154
1026/1155
1027
1028
1030
1031
1032
1033
1037
1047
1068
1069
1070
1071
1073
1074
1075
1076
1077
1078
1079
1080
1081
1082
1083
1084
1085
1087
1091
1097
1112/1156
1113
1122/1157
1123/1158
1130/1164
1132
1136
1137
1150
1151
1152
1159
1165
1166
1278
1279
1303
1364
1376
1377
JEF
KEIS





Platform specific



Acorn
Adobe Standard
Apple II
ATASCII
Atari ST
BICS
Casio calculators
CDC
CPC
DEC Radix-50
DEC MCS/NRCS
DG International
ELWRO-Junior
FIELDATA
GEM
GEOS
GSM 03.38
HP Roman Extension
HP Roman-8
HP Roman-9
HP FOCAL
HP RPL
LICS
LMBCS
MSX
NEC APC
NeXT
PCW
PETSCII
Sharp calculators
TI calculators
TRS-80
Ventura International
Ventura Symbol
WISCII
XCCS
ZX80
ZX81
ZX Spectrum





Unicode¬†/ ISO/IEC 10646



UTF-1
UTF-7
UTF-8
UTF-16 (UTF-16LE/UTF-16BE)¬†/ UCS-2
UTF-32 (UTF-32LE/UTF-32BE)¬†/ UCS-4
UTF-EBCDIC
GB 18030
BOCU-1
CESU-8
SCSU





Miscellaneous code pages



ABICOMP
APL
ARIB STD-B24
Cork
HZ
INIS
INIS-8
Johab
LY1
OML
OMS
OT1
SEASCII
TACE16
TRON
UTF-5
UTF-6
WTF-8





Related topics



Code page
Control character¬†(C0 C1)
CCSID
Character encodings in HTML
Charset detection
Han unification
Hardware
ISO 6429/IEC 6429/ANSI X3.64
Mojibake






 Character sets










v
t
e


Rob Pike



Operating systems



Plan 9 from Bell Labs
Inferno





Programming languages



Newsqueak
Limbo
Go
Sawzall





Software



acme
Blit
sam
rio
8¬Ω





Publications



The Practice of Programming
The Unix Programming Environment





Other



Ren√©e French
Mark V. Shaney
UTF-8












v
t
e


Ken Thompson



Operating systems



Unix
Plan 9 from Bell Labs





Programming languages



B
Bon
Go





Software



Belle
ed
grep
sam
Space Travel
Thompson shell





Other



UTF-8











						Retrieved from "https://en.wikipedia.org/w/index.php?title=UTF-8&oldid=818432906"					Categories: Character encodingComputer-related introductions in 1993EncodingsUnicode Transformation FormatsHidden categories: CS1 Japanese-language sources (ja)All articles with unsourced statementsArticles with unsourced statements from August 2014Articles with unsourced statements from March 2016Articles with unsourced statements from December 2016Pages using RFC magic links